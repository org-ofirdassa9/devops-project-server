
# Generated by CodiumAI
from app.schemas.user_schema import UserUpdate
from app.models.models import User
from app.api.users_service.endpoints.user import update_user
from fastapi import HTTPException
import pytest

class TestUpdateUser:

    # update user email, first name, and last name
    @pytest.mark.asyncio
    async def test_update_user_email_first_name_last_name(self, mocker):
        # Arrange
        from datetime import date
        user_id = 1
        user_update = UserUpdate(email="newemail@example.com", first_name="New", last_name="Name")
        db = mocker.Mock()
        authorize = mocker.Mock()
        authorize.jwt_required.return_value = None

        user_in_db = User(
            user_id=user_id,
            email="oldemail@example.com",
            first_name="Old",
            last_name="Name",
            registration_date=date.today(),
            isAdmin=False
        )
        db.query.return_value.filter.return_value.first.return_value = user_in_db

        # Act
        response = await update_user(user_id, user_update, db, authorize)

        # Assert
        assert response.email == "newemail@example.com"
        assert response.first_name == "New"
        assert response.last_name == "Name"
        assert response.user_id == user_id
        assert response.registration_date == user_in_db.registration_date
        assert response.isAdmin == user_in_db.isAdmin

    # update user first name only
    @pytest.mark.asyncio
    async def test_update_user_first_name_only(self, mocker):
        # Arrange
        from datetime import date
        user_id = 1
        user_update = UserUpdate(first_name="New")
        db_mock = mocker.Mock()

        # Mock the authorize object
        authorize_mock = mocker.Mock()
        authorize_mock.jwt_required.return_value = None

        # Mock the query method of the database session
        query_mock = db_mock.query.return_value
        query_mock.filter.return_value.first.return_value = User(user_id=1, email="test@example.com", first_name="Old", last_name="User", registration_date=date.today(), isAdmin=False)

        # Act
        response = await update_user(user_id, user_update, db_mock, authorize=authorize_mock)

        # Assert
        assert response.email == 'test@example.com'
        assert response.first_name == "New"
        assert response.last_name == 'User'
        db_mock.commit.assert_called_once()
        db_mock.refresh.assert_called_once_with(query_mock.filter.return_value.first.return_value)

    # user_id does not exist
    @pytest.mark.asyncio
    async def test_update_user_user_id_not_exist_fixed(self, mocker):
        # Arrange
        user_id = 1000
        user_update = UserUpdate(email="newemail@example.com", first_name="New", last_name="Name")
        db = mocker.Mock()
        authorize = mocker.Mock()
        db.query.return_value.filter.return_value.first.return_value = None

        # Act and Assert
        with pytest.raises(HTTPException):
            await update_user(user_id, user_update, db, authorize)

    # user_id is negative
    @pytest.mark.asyncio
    async def test_update_user_user_id_negative(self, mocker):
        # Arrange
        user_id = -1
        user_update = UserUpdate(email="newemail@example.com", first_name="New", last_name="Name")
        db = mocker.Mock()
        authorize = mocker.Mock()
        authorize.jwt_required.return_value = None

        # Act and Assert
        with pytest.raises(HTTPException):
            await update_user(user_id, user_update, db, authorize)

    # user_id is zero
    @pytest.mark.asyncio
    async def test_update_user_user_id_zero_with_mock_authorize(self, mocker):
        # Arrange
        user_id = 0
        user_update = UserUpdate(email="newemail@example.com", first_name="New", last_name="Name")
    
        # Create a mock object for the 'db' parameter
        mock_db = mocker.Mock()
        mock_db.query.return_value.filter.return_value.first.return_value = None
    
        # Create a mock object for the 'authorize' parameter
        mock_authorize = mocker.Mock()
        mock_authorize.jwt_required.return_value = None
    
        # Act and Assert
        with pytest.raises(HTTPException):
            await update_user(user_id, user_update, db=mock_db, authorize=mock_authorize)