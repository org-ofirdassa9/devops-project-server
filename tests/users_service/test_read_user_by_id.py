
# Generated by CodiumAI
from app.models.models import User
from app.models.models import HealthMetrics
from app.api.users_service.endpoints.user import read_user_by_id
from app.schemas.health_metrics import UserWithFullHealthMetrics
from fastapi import HTTPException
import pytest

class TestReadUserById:

    # Returns a UserWithFullHealthMetrics object when given a valid user_id and the user is an admin, with blood pressure values as floats
    @pytest.mark.asyncio
    async def test_valid_user_id_and_admin_with_float_blood_pressure(self, mocker):
        # Arrange
        user_id = 1
        db = mocker.Mock()
        authorize = mocker.Mock()
        authorize.jwt_required.return_value = None
        authorize.get_raw_jwt.return_value = {"isAdmin": True}

        # Mock the return values of the database queries
        user = User(
            user_id=user_id,
            email="test@example.com",
            first_name="John",
            last_name="Doe"
        )
        health_metrics = HealthMetrics(
            user_id=user_id,
            heart_rate=80,
            blood_pressure=120/80,
            body_temperature=36.5,
            blood_sugar_level=5.0,
            min_heart_rate=60,
            max_heart_rate=100,
            min_blood_pressure=90/60,
            max_blood_pressure=140/90,
            min_body_temperature=35.0,
            max_body_temperature=37.0,
            min_blood_sugar_level=4.0,
            max_blood_sugar_level=6.0
        )
        db.query.return_value.filter.return_value.first.side_effect = [user, health_metrics]

        # Act
        result = await read_user_by_id(user_id, db, authorize)

        # Assert
        assert isinstance(result, UserWithFullHealthMetrics)
        assert result.user_id == user_id
        assert result.email == user.email
        assert result.first_name == user.first_name
        assert result.last_name == user.last_name
        assert result.heart_rate == health_metrics.heart_rate
        assert result.blood_pressure == health_metrics.blood_pressure
        assert result.body_temperature == health_metrics.body_temperature
        assert result.blood_sugar_level == health_metrics.blood_sugar_level
        assert result.min_heart_rate == health_metrics.min_heart_rate
        assert result.max_heart_rate == health_metrics.max_heart_rate
        assert result.min_blood_pressure == health_metrics.min_blood_pressure
        assert result.max_blood_pressure == health_metrics.max_blood_pressure
        assert result.min_body_temperature == health_metrics.min_body_temperature
        assert result.max_body_temperature == health_metrics.max_body_temperature
        assert result.min_blood_sugar_level == health_metrics.min_blood_sugar_level
        assert result.max_blood_sugar_level == health_metrics.max_blood_sugar_level

    # Raises an HTTPException with status code 401 and detail "Not authorized to update this user" when given an invalid user_id
    @pytest.mark.asyncio
    async def test_invalid_user_id(self, mocker):
        # Arrange
        user_id = 999
        db = mocker.Mock()
        authorize = mocker.Mock()
        authorize.jwt_required.side_effect = HTTPException(status_code=401, detail="Not authorized to update this user")

        # Act and Assert
        with pytest.raises(HTTPException) as exc:
            await read_user_by_id(user_id, db, authorize)
        assert exc.value.status_code == 401
        assert exc.value.detail == "Not authorized to update this user"

    # Returns an HTTPException with status code 404 and detail "User not found" when given a valid user_id and the user does not exist
    @pytest.mark.asyncio
    async def test_valid_user_id_and_admin_no_user_data(self, mocker):
        # Arrange
        user_id = 999
        db = mocker.Mock()
        authorize = mocker.Mock()
        authorize.jwt_required.return_value = None
        authorize.get_raw_jwt.return_value = {"isAdmin": True}
        db.query.return_value.filter.return_value.first.return_value = None

        # Act
        with pytest.raises(HTTPException) as exc_info:
            await read_user_by_id(user_id, db, authorize)

        # Assert
        assert exc_info.value.status_code == 404
        assert exc_info.value.detail == "User not found"

    # Returns a UserWithFullHealthMetrics object when given a valid user_id and the user is an admin
    @pytest.mark.asyncio
    async def test_valid_user_id_and_admin_with_health_metrics(self, mocker):
        # Arrange
        user_id = 1
        db = mocker.Mock()
        authorize = mocker.Mock()
        authorize.jwt_required.return_value = None
        authorize.get_raw_jwt.return_value = {"isAdmin": True}

        # Mock the return values of the database queries
        user = User(
            user_id=user_id,
            email="test@example.com",
            first_name="John",
            last_name="Doe"
        )
        health_metrics = HealthMetrics(
            user_id=user_id,
            heart_rate=80,
            blood_pressure=120/80,
            body_temperature=36.5,
            blood_sugar_level=5.0,
            min_heart_rate=60,
            max_heart_rate=100,
            min_blood_pressure=90/60,
            max_blood_pressure=140/90,
            min_body_temperature=35.0,
            max_body_temperature=37.0,
            min_blood_sugar_level=4.0,
            max_blood_sugar_level=6.0
        )
        db.query.return_value.filter.return_value.first.side_effect = [user, health_metrics]

        # Act
        result = await read_user_by_id(user_id, db, authorize)

        # Assert
        assert isinstance(result, UserWithFullHealthMetrics)
        assert result.user_id == user_id
        assert result.email == user.email
        assert result.first_name == user.first_name
        assert result.last_name == user.last_name
        assert result.heart_rate == health_metrics.heart_rate
        assert result.blood_pressure == health_metrics.blood_pressure
        assert result.body_temperature == health_metrics.body_temperature
        assert result.blood_sugar_level == health_metrics.blood_sugar_level
        assert result.min_heart_rate == health_metrics.min_heart_rate
        assert result.max_heart_rate == health_metrics.max_heart_rate
        assert result.min_blood_pressure == health_metrics.min_blood_pressure
        assert result.max_blood_pressure == health_metrics.max_blood_pressure
        assert result.min_body_temperature == health_metrics.min_body_temperature
        assert result.max_body_temperature == health_metrics.max_body_temperature
        assert result.min_blood_sugar_level == health_metrics.min_blood_sugar_level
        assert result.max_blood_sugar_level == health_metrics.max_blood_sugar_level

    # Raises an HTTPException with status code 404 when given an invalid user_id
    @pytest.mark.asyncio
    async def test_invalid_user_id_and_admin(self, mocker):
        # Arrange
        user_id = 1
        db = mocker.Mock()
        authorize = mocker.Mock()
        authorize.jwt_required.return_value = None
        authorize.get_raw_jwt.return_value = {"isAdmin": True}

        # Mock the return values of the database queries
        db.query.return_value.filter.return_value.first.return_value = None

        # Act and Assert
        with pytest.raises(HTTPException) as exc:
            await read_user_by_id(user_id, db, authorize)
    
        assert exc.value.status_code == 404
        assert exc.value.detail == "User not found"